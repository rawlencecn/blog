<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="my blog">
    <meta name="keyword" content="&#39;NoWayBack&#39;, &#39;Rawlence&#39;, &#39;blog&#39;, &#39;nowayback&#39;, &#39;WebDesign&#39;, &#39;fe&#39;">
    <meta name="theme-color" content="#600090">
    <meta name="msapplication-navbutton-color" content="#600090">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="#600090">
    <link rel="shortcut icon" href="./image/logo.png">
    <link rel="alternate" type="application/atom+xml" title="Rawlence" href="/atom.xml">
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/animate.css/3.5.2/animate.min.css">
    <link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.css">
    <title>
        
        春招面经总结｜NoWayBack
        
    </title>

    <link rel="canonical" href="https://nowayback.cn/2019/05/31/春招面经总结/">

    <!-- Bootstrap Core CSS -->
    
<link rel="stylesheet" href="/css/bootstrap.min.css">


    <!-- Custom CSS -->
    
<link rel="stylesheet" href="/css/blog-style.css">


    <!-- Pygments Github CSS -->
    
<link rel="stylesheet" href="/css/syntax.css">

<meta name="generator" content="Hexo 5.4.0"></head>

<style>

    header.intro-header {
        background-image: url('https://s2.ax1x.com/2019/11/13/MYYzeU.jpg')
    }
</style>
<!-- hack iOS CSS :active style -->
<body ontouchstart="" class="animated fadeIn">
<!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top " id="nav-top" data-ispost = "true" data-istags="false
" data-ishome = "false" >
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand animated pulse" href="/">
                <span class="brand-logo">
                    Rawlence
                </span>
                's Blog
            </a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <!-- Known Issue, found by Hux:
            <nav>'s height woule be hold on by its content.
            so, when navbar scale out, the <nav> will cover tags.
            also mask any touch event of tags, unfortunately.
        -->
        <!-- /.navbar-collapse -->
        <div id="huxblog_navbar">
            <div class="navbar-collapse">
                <ul class="nav navbar-nav navbar-right">
                    <li>
                        <a href="/">Home</a>
                    </li>
                    <li>
                        <a href="/my-works/">My Works</a>
                    </li>
                    <li>
                        <a href="/Tags/">Tags</a>
                    </li>
                    <li>
                        <a href="/about/">About</a>
                    </li>
					
                    
                        
                    
                        
                    
                        
                    
                        
                    
					
					
                </ul>
            </div>
        </div>
    </div>
    <!-- /.container -->
</nav>
<script>
    // Drop Bootstarp low-performance Navbar
    // Use customize navbar with high-quality material design animation
    // in high-perf jank-free CSS3 implementation
//    var $body   = document.body;
    var $toggle = document.querySelector('.navbar-toggle');
    var $navbar = document.querySelector('#huxblog_navbar');
    var $collapse = document.querySelector('.navbar-collapse');
    var $loadingBar = document.querySelector('.navbar-custom.is-fixed::before');

    $toggle.addEventListener('click', handleMagic)
    function handleMagic(e){
        if ($navbar.className.indexOf('in') > 0) {
        // CLOSE
            $navbar.className = " ";
            // wait until animation end.
            setTimeout(function(){
                // prevent frequently toggle
                if($navbar.className.indexOf('in') < 0) {
                    $collapse.style.height = "0px"
                }
            },400)
        }else{
        // OPEN
            $collapse.style.height = "auto"
            $navbar.className += " in";
        }
    }
    window.onload =function()
    {
        document.styleSheets[3].addRule('.navbar-custom.is-fixed::before', 'opacity: 0');
    }
</script>

<!-- Main Content -->

<!--only post-->


<img class="wechat-title-img"
     src="https://s2.ax1x.com/2019/11/13/MYYzeU.jpg">


<style>
    
    header.intro-header {
        background-image: url('https://s2.ax1x.com/2019/11/13/MYYzeU.jpg')
    }

    
</style>

<header class="intro-header">
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1 text-center">
                <div class="post-heading">
                    <h1>春招面经总结</h1>
                    
                    <span class="meta">
                         作者 Lei Zhang
                        <span>
                          日期 2019-05-31
                         </span>
                    </span>
                    <div class="tags text-center">
                        
                        <a class="tag" href="/tags/#面经"
                           title="面经">面经</a>
                        
                    </div>
                </div>
            </div>
        </div>
    </div>
    <div class="post-title-haojen">
        <span>
            春招面经总结
        </span>
    </div>
</header>

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">
            <!-- Post Container -->
            <div class="col-lg-10 col-sm-9 post-container">
                <blockquote>
<p>​来到五月底，19年春招（暑期实习）已经基本接近尾声。对我个人来说，虽然结果不能说有多好，但至少在面试的过程中，通过与面试官的不断交流，我对前端的认知有了更深的了解，对今后的学习路线也有了大体的规划。在这里简单总结一些面试中遇到的印象比较深（坑）或者当时答得不太好的问题，为秋招留作参考。</p>
</blockquote>
<hr>
<h3 id="1-闭包"><a href="#1-闭包" class="headerlink" title="1. 闭包"></a>1. 闭包</h3><h4 id="概念："><a href="#概念：" class="headerlink" title="概念："></a>概念：</h4><p><strong>闭包就是有权访问另一个函数作用域中变量的函数</strong></p>
<h4 id="示例代码："><a href="#示例代码：" class="headerlink" title="示例代码："></a>示例代码：</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">var</span> b = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> bar;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = foo();</span><br><span class="line">bar();</span><br></pre></td></tr></table></figure>

<p>在上例中，首先有执行上下文<strong>foo</strong>，在foo中定义了函数<strong>bar</strong>，通过对外返回<strong>bar</strong>的方式，让bar得以执行。</p>
<p>当bar执行时，访问了<strong>foo</strong>内部的变量a, b。此时闭包就会产生</p>
<h4 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h4><p>首先需要了解JavaScript引擎的垃圾回收机制。垃圾回收机制有一个重要的行为：当一个值在内存中失去引用时，垃圾回收机制会根据特殊的算法找到它，并将其回收，释放内存。函数的执行上下文，在执行完毕之后，生命周期结束，那么该函数的执行上下文就会失去引用。其占用的内存空间很快就会被垃圾回收器释放。</p>
<p>而上例中，<code>foo()</code>执行完毕后，bar扔保持着对其内部变量的引用，从而使foo未被回收。所以此时仍能访问到变量a, b的值。</p>
<h4 id="应用场景："><a href="#应用场景：" class="headerlink" title="应用场景："></a>应用场景：</h4><h5 id="模块化"><a href="#模块化" class="headerlink" title="- 模块化"></a>- 模块化</h5><p>私有化便令，且可防止污染全局作用域</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">var</span> b = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> num1 = !!num1 ? num1 : a;</span><br><span class="line">        <span class="keyword">var</span> num2 = !!num2 ? num2 : b;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> num1 + num2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">window</span>.add = add;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">add(<span class="number">10</span>, <span class="number">20</span>);</span><br></pre></td></tr></table></figure>

<h5 id="柯里化（比较难理解，在这里就不详细展开了）"><a href="#柯里化（比较难理解，在这里就不详细展开了）" class="headerlink" title="- 柯里化（比较难理解，在这里就不详细展开了）"></a>- 柯里化（比较难理解，在这里就不详细展开了）</h5><h6 id="概念：-1"><a href="#概念：-1" class="headerlink" title="概念："></a>概念：</h6><p><strong>柯里化是指这样一个函数(假设叫做createCurry)，他接收函数A作为参数，运行后能够返回一个新的函数。并且这个新的函数能够处理函数A的剩余参数。</strong></p>
<h6 id="简单实现："><a href="#简单实现：" class="headerlink" title="简单实现："></a>简单实现：</h6><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createCurry</span>(<span class="params">func, args</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> arity = func.length;</span><br><span class="line">    <span class="keyword">var</span> args = args || [];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> _args = [].slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">        [].unshift.apply(_args, args);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果参数个数小于最初的func.length，则递归调用，继续收集参数</span></span><br><span class="line">        <span class="keyword">if</span> (_args.length &lt; arity) &#123;</span><br><span class="line">            <span class="keyword">return</span> createCurry.call(<span class="built_in">this</span>, func, _args);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 参数收集完毕，则执行func</span></span><br><span class="line">        <span class="keyword">return</span> func.apply(<span class="built_in">this</span>, _args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2-MVVM与MVC"><a href="#2-MVVM与MVC" class="headerlink" title="2.MVVM与MVC"></a>2.MVVM与MVC</h3><h4 id="MVVM核心："><a href="#MVVM核心：" class="headerlink" title="- MVVM核心："></a>- MVVM核心：</h4><p>【<strong>视图模型</strong>】mvvm模式的核心，它是连接view和model的桥梁。</p>
<p>它有两个方向：一是将【模型】转化成【视图】，即将后端传递的数据转化成所看到的页面。实现的方式是：数据绑定。二是将【视图】转化成【模型】，即将所看到的页面转化成后端的数据。实现的方式是：DOM 事件监听。这两个方向都实现的，我们称之为数据的双向绑定。</p>
<p>总结：在MVVM的框架下视图和模型是不能直接通信的。它们通过ViewModel来通信，ViewModel通常要实现一个observer观察者，当数据发生变化，ViewModel能够监听到数据的这种变化，然后通知到对应的视图做自动更新，而当用户操作视图，ViewModel也能监听到视图的变化，然后通知数据做改动，这实际上就实现了数据的双向绑定。并且MVVM中的View 和 ViewModel可以互相通信。</p>
<h3 id="3-HTTP1-0-HTTP1-1-HTTP2"><a href="#3-HTTP1-0-HTTP1-1-HTTP2" class="headerlink" title="3.HTTP1.0/HTTP1.1/HTTP2"></a>3.HTTP1.0/HTTP1.1/HTTP2</h3><h4 id="支持方法变动"><a href="#支持方法变动" class="headerlink" title="- 支持方法变动"></a>- 支持方法变动</h4><p>HTTP1.1新增OPTIONS, TRACE, CONNECT，废弃LINK, UNLINK</p>
<h4 id="持久化连接"><a href="#持久化连接" class="headerlink" title="- 持久化连接"></a>- 持久化连接</h4><p>HTTP1.1中所有的连接默认都是持久连接</p>
<h4 id="HTTP2-特性"><a href="#HTTP2-特性" class="headerlink" title="- HTTP2 特性"></a>- HTTP2 特性</h4><ul>
<li>多路复用（复用同一个TCP连接）</li>
<li>以二进制传输数据</li>
<li>Header压缩</li>
<li>服务端push</li>
</ul>
<h4 id="HTTP1-1的升级"><a href="#HTTP1-1的升级" class="headerlink" title="- HTTP1.1的升级"></a>- HTTP1.1的升级</h4><ul>
<li>100（Continue）状态码</li>
<li>增加Host字段（用于虚拟主机）</li>
</ul>
<h3 id="4-实现一个服务器"><a href="#4-实现一个服务器" class="headerlink" title="4.实现一个服务器"></a>4.实现一个服务器</h3><h4 id="（1）-接受客户端连接"><a href="#（1）-接受客户端连接" class="headerlink" title="（1）  接受客户端连接"></a>（1）  接受客户端连接</h4><ul>
<li>接受客户端发送的TCP连接，将IP地址解析出来</li>
<li>连接建立后，将新连接添加到现存的Web服务器连接列表</li>
<li>识别客户端主机（此处可通过“反向DNS”对大部分Web服务器进行配置）</li>
</ul>
<h4 id="（2）-接受请求报文"><a href="#（2）-接受请求报文" class="headerlink" title="（2）  接受请求报文"></a>（2）  接受请求报文</h4><ul>
<li><p>解析请求行</p>
</li>
<li><p>监控请求</p>
<ul>
<li>单线程</li>
<li>多进程及多线程</li>
<li>复用I/O</li>
<li>复用多线程</li>
</ul>
</li>
<li><p>处理请求</p>
</li>
<li><p>对资源的映射及访问</p>
</li>
<li><p>构建响应</p>
<ul>
<li>相应实体</li>
<li>MIME类型</li>
<li>重定向</li>
</ul>
</li>
<li><p>发送响应</p>
</li>
<li><p>记录日志</p>
</li>
</ul>
<h3 id="5-Vue组件间通信"><a href="#5-Vue组件间通信" class="headerlink" title="5.Vue组件间通信"></a>5.Vue组件间通信</h3><h4 id="父子通信"><a href="#父子通信" class="headerlink" title="- 父子通信"></a>- 父子通信</h4><ul>
<li><p>父组件通过<code>props</code>传递数据给子组件，子组件通过<code>emit</code>发送事件传递数据给父组件</p>
</li>
<li><p>通过<code>$parent</code>和<code>$children</code>直接访问父、子实例</p>
</li>
<li><p><code>$listeners</code>和<code>.sync</code>(&gt;=Vue@2.3), <code>$listeners</code>属性会将父组件中(不含 .native 修饰器的) v-on 事件监听器传递给子组件，子组件可以通过访问 $listeners 来自定义监听器。</p>
<p><code>.sync</code>用法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;!--父组件中--&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">:value.sync</span>=<span class="string">&quot;value&quot;</span> /&gt;</span></span></span><br><span class="line">&lt;!--以上写法等同于--&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">:value</span>=<span class="string">&quot;value&quot;</span> @<span class="attr">update:value</span>=<span class="string">&quot;v =&gt; value = v&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">comp</span>&gt;</span></span></span><br><span class="line">&lt;!--子组件中--&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="built_in">this</span>.$emit(<span class="string">&#x27;update:value&#x27;</span>, <span class="number">1</span>)</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="兄弟组件"><a href="#兄弟组件" class="headerlink" title="- 兄弟组件"></a>- 兄弟组件</h4><p>通过<code>this.$parent.$children</code>，然后根据组件的name查询到需要的实例</p>
<h4 id="跨多层级"><a href="#跨多层级" class="headerlink" title="- 跨多层级"></a>- 跨多层级</h4><p>对于这种情况可以使用 Vue 2.2 新增的 API <code>provide / inject</code>，虽然文档中不推荐直接使用在业务中，但是如果用得好的话还是很有用的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 父组件 A</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">provide</span>: &#123;</span><br><span class="line">    <span class="attr">data</span>: <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 子组件 B</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">inject</span>: [<span class="string">&#x27;data&#x27;</span>],</span><br><span class="line">  <span class="function"><span class="title">mounted</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 无论跨几层都能获得父组件的 data 属性</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.data) <span class="comment">// =&gt; 1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="任意组件"><a href="#任意组件" class="headerlink" title="- 任意组件"></a>- 任意组件</h4><p>这种方式可以通过 Vuex 或者 Event Bus 解决，另外如果你不怕麻烦的话，可以使用这种方式解决上述所有的通信情况</p>
<h3 id="6-缓存相关"><a href="#6-缓存相关" class="headerlink" title="6.缓存相关"></a>6.缓存相关</h3><h4 id="强缓存（强缓存表示在缓存期间不需要请求，state-code-为-200）"><a href="#强缓存（强缓存表示在缓存期间不需要请求，state-code-为-200）" class="headerlink" title="- 强缓存（强缓存表示在缓存期间不需要请求，state code 为 200）"></a>- 强缓存（强缓存表示在缓存期间不需要请求，<code>state code</code> 为 200）</h4><ul>
<li><p>Expires（HTTP/1）</p>
<p>需注意，如果修改了本地时间，可能会造成缓存失效</p>
</li>
</ul>
<ul>
<li><p>Cache-Control(HTTP/1.1)</p>
<p>优先级高于Expires，但当HTTP版本为1.0时，会忽略<strong>Cache-Control</strong></p>
<p><img src="Cache-Control.jpg" alt="Cache-Control的组合指令"></p>
</li>
</ul>
<h4 id="协商缓存（如果缓存过期了，就需要发起请求验证资源是否有更新）"><a href="#协商缓存（如果缓存过期了，就需要发起请求验证资源是否有更新）" class="headerlink" title="- 协商缓存（如果缓存过期了，就需要发起请求验证资源是否有更新）"></a>- 协商缓存（如果缓存过期了，就需要发起请求验证资源是否有更新）</h4><p>协商缓存可以通过设置两种 HTTP Header 实现：<code>Last-Modified</code> 和 <code>ETag</code> 。</p>
<p>当浏览器发起请求验证资源时，如果资源没有做改变，那么服务端就会返回 304 状态码，并且更新浏览器缓存有效期。</p>
<p><img src="%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98.jpg" alt="协商缓存"></p>
<ul>
<li><p>Last-Modified 和 If-Modified-Since</p>
<p><code>Last-Modified</code> 表示本地文件最后修改日期，<code>If-Modified-Since</code> 会将 <code>Last-Modified</code> 的值发送给服务器，询问服务器在该日期后资源是否有更新，有更新的话就会将新的资源发送回来，否则返回 304 状态码。</p>
<p>但是 <code>Last-Modified</code> 存在一些弊端：</p>
<ul>
<li>如果本地打开缓存文件，即使没有对文件进行修改，但还是会造成 <code>Last-Modified</code> 被修改，服务端不能命中缓存导致发送相同的资源</li>
<li>因为 <code>Last-Modified</code> 只能以秒计时，如果在不可感知的时间内(1s内)修改完成文件，那么服务端会认为资源还是命中了，不会返回正确的资源</li>
</ul>
</li>
<li><h4 id="ETag-和-If-None-Match"><a href="#ETag-和-If-None-Match" class="headerlink" title="ETag 和 If-None-Match"></a>ETag 和 If-None-Match</h4><p><code>ETag</code> 类似于文件指纹，<code>If-None-Match</code> 会将当前 <code>ETag</code> 发送给服务器，询问该资源 <code>ETag</code> 是否变动，有变动的话就将新的资源发送回来。并且 <code>ETag</code> 优先级比 <code>Last-Modified</code> 高。</p>
</li>
</ul>
<h4 id="浏览器默认策略"><a href="#浏览器默认策略" class="headerlink" title="- 浏览器默认策略"></a>- 浏览器默认策略</h4><p>对于这种情况，浏览器会采用一个启发式的算法，通常会取响应头中的 <code>Date</code> 减去 <code>Last-Modified</code> 值的 10% 作为缓存时间。</p>
<h3 id="7-DNS解析过程"><a href="#7-DNS解析过程" class="headerlink" title="7.DNS解析过程"></a>7.DNS解析过程</h3><ul>
<li>系统会检查本地缓存（浏览器，hosts等）是否存在域名映射</li>
<li>如果本地DNS缓存没有命中，则查找本地DNS服务器</li>
<li>本地DNS服务器会把请求发至根DNS服务器，根DNS服务器收到请求后会返回一个负责该顶级域名服务器的IP。本地DNS服务器收到IP后，将会请求这个IP对应的服务器，就这样逐层查找，直至找到主机。</li>
</ul>
<h3 id="8-跨域（通过代理方式）"><a href="#8-跨域（通过代理方式）" class="headerlink" title="8.跨域（通过代理方式）"></a>8.跨域（通过代理方式）</h3><p>代理服务器解决跨域的思路是利用代理服务器对浏览器页面的请求进行转发，因为同源策略的限制只存在在浏览器中，到了服务器端就没有这个限制了，常用的代理服务器方案有使用反向代理服务器以及服务器内转发，使用反向代理服务器的例子是Nginx的反向代理，通过修改Nginx的配置文件，将指定的不同源域名代理到当前服务器上，浏览器就可以正常访问不同源的资源了。还有个方案是不依赖反向代理服务器，在server端对不同源的API进行转发。</p>
<h4 id="转发不同源请求"><a href="#转发不同源请求" class="headerlink" title="- 转发不同源请求"></a>- 转发不同源请求</h4><p>首先代理服务器需要知道浏览器页面需要请求的API，因此，页面需要把API当做参数传递给代理服务器，形如：<code>/proxy/:api</code>，api参数是完整的API链接，如之前提到的豆瓣公共API：<a target="_blank" rel="noopener" href="https://api.douban.com/v2/book/1220562">https://api.douban.com/v2/book/1220562</a> 。server端对API进行转发，在Python中可以使用<code>requests</code>发起HTTP请求，nodejs可以使用<code>request</code>，server端获得响应后将响应的结果返回给浏览器，具体的实现也很简单，以Flask为例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/proxy/&lt;path:url&gt;&#x27;</span>, methods=[<span class="string">&#x27;GET&#x27;</span>]</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getTasks</span>(<span class="params">url</span>):</span></span><br><span class="line">	r = requests.get(url) <span class="comment">## 请求转发</span></span><br><span class="line">	conver_r = <span class="built_in">eval</span>(<span class="built_in">bytes</span>.decode(r.content)) <span class="comment">##进行一些类型转化</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> json.dumps(conver_r), <span class="number">200</span></span><br></pre></td></tr></table></figure>

<p>在浏览器端发起请求的具体代码为：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">self.$http.get(<span class="string">&#x27;/proxy/https://api.douban.com/v2/book/1220562&#x27;</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">res</span>) </span>&#123;</span><br><span class="line">	self.data = <span class="built_in">JSON</span>.parse(res.data)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="反向代理"><a href="#反向代理" class="headerlink" title="- 反向代理"></a>- 反向代理</h4><p>如<code>www.a.com</code>跨域访问<code>www.b.com/login</code>接口，可将网页中的目标网址改为<code>www.a.com/apis/login</code></p>
<p>通过nginx配置，示例：</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span>       <span class="number">80</span>;</span><br><span class="line">        <span class="attribute">server_name</span>  www.a.com;</span><br><span class="line">        <span class="attribute">access_log</span>  logs/test.access.log;</span><br><span class="line">        <span class="comment"># 匹配以/apis/开头的请求</span></span><br><span class="line">        <span class="attribute">location</span><span class="regexp"> ^~</span> /apis/ &#123;</span><br><span class="line">            <span class="attribute">proxy_pass</span> http://www.b.com/; <span class="comment">#注意域名后有一个/  无‘/’会访问www.b.com/apis/login</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="attribute">location</span> / &#123;</span><br><span class="line">            <span class="attribute">root</span> html/a;</span><br><span class="line">            <span class="attribute">index</span> index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">#</span></span><br><span class="line">        <span class="attribute">error_page</span>   <span class="number">500</span> <span class="number">502</span> <span class="number">503</span> <span class="number">504</span>  /50x.html;</span><br><span class="line">        <span class="attribute">location</span> = /50x.html &#123;</span><br><span class="line">            <span class="attribute">root</span>   html;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h3 id="9-CSRF相关"><a href="#9-CSRF相关" class="headerlink" title="9.CSRF相关"></a>9.CSRF相关</h3><p>CSRF（Cross Site Request Forgery），中文是跨站点请求伪造。CSRF攻击者在用户已经登录目标网站之后，诱使用户访问一个攻击页面，利用目标网站对用户的信任，以用户身份在攻击页面对目标网站发起伪造用户操作的请求，达到攻击目的。</p>
<h4 id="示例攻击过程"><a href="#示例攻击过程" class="headerlink" title="- 示例攻击过程"></a>- 示例攻击过程</h4><blockquote>
<p>假如博客园有个加关注的GET接口，blogUserGuid参数很明显是关注人Id，如下：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">http</span>://www.cnblogs.com/mvc/Follow/FollowBlogger.aspx?blogUserGuid=<span class="number">4</span>e<span class="number">8</span>c<span class="number">33</span>d<span class="number">0</span>-<span class="number">77</span>fe-df<span class="number">11</span>-ac<span class="number">81</span>-<span class="number">842</span>b<span class="number">2</span>b<span class="number">196315</span></span><br></pre></td></tr></table></figure>

<p>那我只需要在我的一篇博文内容里面写一个img标签：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">&lt;img <span class="attribute">style</span>=<span class="string">&quot;width:0;&quot;</span> <span class="attribute">src</span>=<span class="string">&quot;http://www.cnblogs.com/mvc/Follow/FollowBlogger.aspx?blogUserGuid=4e8c33d0-77fe-df11-ac81-842b2b196315&quot;</span>   /&gt;</span><br></pre></td></tr></table></figure>

<p>那么只要有人打开我这篇博文，那就会自动关注我。</p>
</blockquote>
<h4 id="防御措施"><a href="#防御措施" class="headerlink" title="- 防御措施"></a>- 防御措施</h4><p><strong>1. 尽量使用POST，限制GET</strong></p>
<p>GET接口太容易被拿来做CSRF攻击，看第示例就知道，只要构造一个img标签，而img标签又是不能过滤的数据。接口最好限制为POST使用，GET则无效，降低攻击风险。</p>
<p>当然POST并不是万无一失，攻击者只要构造一个form就可以，但需要在第三方页面做，这样就增加暴露的可能性。</p>
<p><strong>2. 浏览器Cookie策略</strong></p>
<p>IE6、7、8、Safari会默认拦截第三方本地Cookie（Third-party Cookie）的发送。但是Firefox2、3、Opera、Chrome、Android等不会拦截，所以通过浏览器Cookie策略来防御CSRF攻击不靠谱，只能说是降低了风险。</p>
<p>PS：Cookie分为两种，Session Cookie（在浏览器关闭后，就会失效，保存到内存里），Third-party Cookie（即只有到了Exprie时间后才会失效的Cookie，这种Cookie会保存到本地）。</p>
<p>PS：另外如果网站返回HTTP头包含P3P Header，那么将允许浏览器发送第三方Cookie。</p>
<p><strong>3. 加验证码</strong></p>
<p>验证码，强制用户必须与应用进行交互，才能完成最终请求。在通常情况下，验证码能很好遏制CSRF攻击。但是出于用户体验考虑，网站不能给所有的操作都加上验证码。因此验证码只能作为一种辅助手段，不能作为主要解决方案。</p>
<p><strong>4. Referer Check</strong></p>
<p>Referer Check在Web最常见的应用就是“防止图片盗链”。同理，Referer Check也可以被用于检查请求是否来自合法的“源”（Referer值是否是指定页面，或者网站的域），如果都不是，那么就极可能是CSRF攻击。</p>
<p>但是因为服务器并不是什么时候都能取到Referer，所以也无法作为CSRF防御的主要手段。但是用Referer Check来监控CSRF攻击的发生，倒是一种可行的方法。</p>
<p><strong>5. Anti CSRF Token</strong></p>
<p>现在业界对CSRF的防御，一致的做法是使用一个Token（Anti CSRF Token）。</p>
<p>例子：</p>
<ul>
<li><p>用户访问某个表单页面。</p>
</li>
<li><p>服务端生成一个Token，放在用户的Session中，或者浏览器的Cookie中。</p>
</li>
<li><p>在页面表单附带上Token参数。</p>
</li>
<li><p>用户提交请求后， 服务端验证表单中的Token是否与用户Session（或Cookies）中的Token一致，一致为合法请求，不是则非法请求。</p>
</li>
</ul>
<p>这个Token的值必须是随机的，不可预测的。由于Token的存在，攻击者无法再构造一个带有合法Token的请求实施CSRF攻击。另外使用Token时应注意Token的保密性，尽量把敏感操作由GET改为POST，以form或AJAX形式提交，避免Token泄露。</p>
<p>注意：</p>
<p>CSRF的Token仅仅用于对抗CSRF攻击。当网站同时存在XSS漏洞时候，那这个方案也是空谈。所以XSS带来的问题，应该使用XSS的防御方案予以解决。</p>
<h3 id="10-WebRTC建立连接的过程"><a href="#10-WebRTC建立连接的过程" class="headerlink" title="10.WebRTC建立连接的过程"></a>10.WebRTC建立连接的过程</h3><p>（不是很好理解，暂时搁置。。）</p>
<h3 id="11-WebSocket怎么实现的（安全）"><a href="#11-WebSocket怎么实现的（安全）" class="headerlink" title="11.WebSocket怎么实现的（安全）"></a>11.WebSocket怎么实现的（安全）</h3><p>为了实现 WebSocket 通信，在 HTTP 连接建立之后，需要完成一次“握手”（Handshaking）的步骤。</p>
<ul>
<li><p>握手·请求<br>为了实现 WebSocket 通信，需要用到 HTTP 的 Upgrade 首部字段，告知服务器通信协议发生改变，以达到握手的目的。</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/chat</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>server.example.com</span><br><span class="line"><span class="attribute">Upgrade</span><span class="punctuation">: </span>websocket</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>Upgrade</span><br><span class="line"><span class="attribute">Sec-WebSocket-Key</span><span class="punctuation">: </span>dGhlIHNhbXBsZSBub25jZQ==</span><br><span class="line"><span class="attribute">Origin</span><span class="punctuation">: </span>http://example.com</span><br><span class="line"><span class="attribute">Sec-WebSocket-Protocol</span><span class="punctuation">: </span>chat, superchat</span><br><span class="line"><span class="attribute">Sec-WebSocket-Version</span><span class="punctuation">: </span>13</span><br></pre></td></tr></table></figure>

<p><code>Sec-WebSocket-Key</code> 字段内记录着握手过程中必不可少的键值。<br><code>Sec-WebSocket-Protocol</code>字段内记录使用的子协议。<br>子协议按 WebSocket 协议标准在连接分开使用时，定义那些连接的名称。</p>
</li>
<li><p>握手·响应<br>对于之前的请求，返回状态码 101 Switching Protocols 的响应。</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="meta">HTTP/1.1</span> <span class="number">101</span> Switching Protocols</span><br><span class="line"><span class="attribute">Upgrade</span><span class="punctuation">: </span>websocket</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>Upgrade</span><br><span class="line"><span class="attribute">Sec-WebSocket-Accept</span><span class="punctuation">: </span>s3pPLMBiTxaQ9kYGzzhZRbK+xOo=</span><br><span class="line"><span class="attribute">Sec-WebSocket-Protocol</span><span class="punctuation">: </span>chat</span><br></pre></td></tr></table></figure>

<p><code>Sec-WebSocket-Accept</code> 的字段值是由握手请求中的 <code>Sec-WebSocket-Key</code> 的字段值生成的。<br>成功握手确立 WebSocket 连接之后，通信时不再使用 HTTP 的数据帧，而采用 WebSocket 独立的数据帧。</p>
</li>
</ul>
<h3 id="12-HTTPS如何校验证书合法性"><a href="#12-HTTPS如何校验证书合法性" class="headerlink" title="12.HTTPS如何校验证书合法性"></a>12.HTTPS如何校验证书合法性</h3><p>客户端在对服务器say hello之后，服务器将公开密钥证书发送给客户端，注意这个证书里面包含了公钥+各种信息+签名（签发机构持有私钥，并使用私钥对各种信息加密后生成签名），客户端收到公开密钥证书后，相当于收到了一个包裹里面有公钥+各种信息+签名。那么如何使用这三个数据来校验呢？很简单，公钥加密，私钥解，私钥加密公钥也可以解，只要利用公钥对签名进行解密，然后最和各种信息做比较就可以校验出证书的合法性。</p>
<p>P.S 客户端须持有服务端的公钥才可防御中间人攻击。</p>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/lovesong/p/5233195.html">《Web安全之CSRF攻击》</a></p>
<p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000012859206">《Nginx反向代理解决跨域问题》</a></p>
<p>《HTTP权威指南》</p>
<p>《图解HTTP》</p>

                <hr>
                

                <ul class="pager">
                    
                    <li class="previous">
                        <a href="/2021/08/29/性能优化随笔/" data-toggle="tooltip" data-placement="top"
                           title="性能优化随笔">&larr; Previous Post</a>
                    </li>
                    
                    
                    <li class="next">
                        <a href="/2019/04/08/排序算法总结/" data-toggle="tooltip" data-placement="top"
                           title="排序算法总结">Next Post &rarr;</a>
                    </li>
                    
                </ul>

                

                


                <!--加入新的评论系统-->
                
                <!-- 来必力City版安装代码 -->
                <div id="lv-container" data-id="city" data-uid="MTAyMC80MTYwNy8xODE1NA==">
                    <script type="text/javascript">
                        (function(d, s) {
                            var j, e = d.getElementsByTagName(s)[0];

                            if (typeof LivereTower === 'function') { return; }

                            j = d.createElement(s);
                            j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
                            j.async = true;

                            e.parentNode.insertBefore(j, e);
                        })(document, 'script');
                    </script>
                    <noscript> 为正常使用来必力评论功能请激活JavaScript</noscript>
                </div>
                <!-- City版安装代码已完成 -->
                

                

            </div>

            <div class="hidden-xs col-lg-1 col-lg-offset-1 col-sm-2 toc-col">
                <div class="toc-wrap">
                    <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E9%97%AD%E5%8C%85"><span class="toc-text">1. 闭包</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5%EF%BC%9A"><span class="toc-text">概念：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81%EF%BC%9A"><span class="toc-text">示例代码：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E7%90%86%EF%BC%9A"><span class="toc-text">原理：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9A"><span class="toc-text">应用场景：</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A8%A1%E5%9D%97%E5%8C%96"><span class="toc-text">- 模块化</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9F%AF%E9%87%8C%E5%8C%96%EF%BC%88%E6%AF%94%E8%BE%83%E9%9A%BE%E7%90%86%E8%A7%A3%EF%BC%8C%E5%9C%A8%E8%BF%99%E9%87%8C%E5%B0%B1%E4%B8%8D%E8%AF%A6%E7%BB%86%E5%B1%95%E5%BC%80%E4%BA%86%EF%BC%89"><span class="toc-text">- 柯里化（比较难理解，在这里就不详细展开了）</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5%EF%BC%9A-1"><span class="toc-text">概念：</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0%EF%BC%9A"><span class="toc-text">简单实现：</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-MVVM%E4%B8%8EMVC"><span class="toc-text">2.MVVM与MVC</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#MVVM%E6%A0%B8%E5%BF%83%EF%BC%9A"><span class="toc-text">- MVVM核心：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-HTTP1-0-HTTP1-1-HTTP2"><span class="toc-text">3.HTTP1.0&#x2F;HTTP1.1&#x2F;HTTP2</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%94%AF%E6%8C%81%E6%96%B9%E6%B3%95%E5%8F%98%E5%8A%A8"><span class="toc-text">- 支持方法变动</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%81%E4%B9%85%E5%8C%96%E8%BF%9E%E6%8E%A5"><span class="toc-text">- 持久化连接</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HTTP2-%E7%89%B9%E6%80%A7"><span class="toc-text">- HTTP2 特性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HTTP1-1%E7%9A%84%E5%8D%87%E7%BA%A7"><span class="toc-text">- HTTP1.1的升级</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-text">4.实现一个服务器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%881%EF%BC%89-%E6%8E%A5%E5%8F%97%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%BF%9E%E6%8E%A5"><span class="toc-text">（1）  接受客户端连接</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%882%EF%BC%89-%E6%8E%A5%E5%8F%97%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87"><span class="toc-text">（2）  接受请求报文</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-Vue%E7%BB%84%E4%BB%B6%E9%97%B4%E9%80%9A%E4%BF%A1"><span class="toc-text">5.Vue组件间通信</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%88%B6%E5%AD%90%E9%80%9A%E4%BF%A1"><span class="toc-text">- 父子通信</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%84%E5%BC%9F%E7%BB%84%E4%BB%B6"><span class="toc-text">- 兄弟组件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B7%A8%E5%A4%9A%E5%B1%82%E7%BA%A7"><span class="toc-text">- 跨多层级</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%BB%E6%84%8F%E7%BB%84%E4%BB%B6"><span class="toc-text">- 任意组件</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E7%BC%93%E5%AD%98%E7%9B%B8%E5%85%B3"><span class="toc-text">6.缓存相关</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%BA%E7%BC%93%E5%AD%98%EF%BC%88%E5%BC%BA%E7%BC%93%E5%AD%98%E8%A1%A8%E7%A4%BA%E5%9C%A8%E7%BC%93%E5%AD%98%E6%9C%9F%E9%97%B4%E4%B8%8D%E9%9C%80%E8%A6%81%E8%AF%B7%E6%B1%82%EF%BC%8Cstate-code-%E4%B8%BA-200%EF%BC%89"><span class="toc-text">- 强缓存（强缓存表示在缓存期间不需要请求，state code 为 200）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98%EF%BC%88%E5%A6%82%E6%9E%9C%E7%BC%93%E5%AD%98%E8%BF%87%E6%9C%9F%E4%BA%86%EF%BC%8C%E5%B0%B1%E9%9C%80%E8%A6%81%E5%8F%91%E8%B5%B7%E8%AF%B7%E6%B1%82%E9%AA%8C%E8%AF%81%E8%B5%84%E6%BA%90%E6%98%AF%E5%90%A6%E6%9C%89%E6%9B%B4%E6%96%B0%EF%BC%89"><span class="toc-text">- 协商缓存（如果缓存过期了，就需要发起请求验证资源是否有更新）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ETag-%E5%92%8C-If-None-Match"><span class="toc-text">ETag 和 If-None-Match</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E9%BB%98%E8%AE%A4%E7%AD%96%E7%95%A5"><span class="toc-text">- 浏览器默认策略</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-DNS%E8%A7%A3%E6%9E%90%E8%BF%87%E7%A8%8B"><span class="toc-text">7.DNS解析过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E8%B7%A8%E5%9F%9F%EF%BC%88%E9%80%9A%E8%BF%87%E4%BB%A3%E7%90%86%E6%96%B9%E5%BC%8F%EF%BC%89"><span class="toc-text">8.跨域（通过代理方式）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%AC%E5%8F%91%E4%B8%8D%E5%90%8C%E6%BA%90%E8%AF%B7%E6%B1%82"><span class="toc-text">- 转发不同源请求</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86"><span class="toc-text">- 反向代理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-CSRF%E7%9B%B8%E5%85%B3"><span class="toc-text">9.CSRF相关</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E6%94%BB%E5%87%BB%E8%BF%87%E7%A8%8B"><span class="toc-text">- 示例攻击过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%B2%E5%BE%A1%E6%8E%AA%E6%96%BD"><span class="toc-text">- 防御措施</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-WebRTC%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-text">10.WebRTC建立连接的过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-WebSocket%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%88%E5%AE%89%E5%85%A8%EF%BC%89"><span class="toc-text">11.WebSocket怎么实现的（安全）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-HTTPS%E5%A6%82%E4%BD%95%E6%A0%A1%E9%AA%8C%E8%AF%81%E4%B9%A6%E5%90%88%E6%B3%95%E6%80%A7"><span class="toc-text">12.HTTPS如何校验证书合法性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE"><span class="toc-text">参考文献</span></a></li></ol>
                </div>
            </div>
        </div>

        <div class="row">
            <!-- Sidebar Container -->

            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                sidebar-container">

                <!-- Featured Tags -->
                
                <section>
                    <!-- no hr -->
                    <h5 class="text-center">
                        <a href="/tags/">FEATURED TAGS</a>
                    </h5>
                    <div class="tags">
                        
                        <a class="tag" href="/tags/#面经"
                           title="面经">面经</a>
                        
                    </div>
                </section>
                

                <!-- Friends Blog -->
                
            </div>
        </div>

    </div>
</article>







<!-- Footer -->
<!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1 text-center">
                <br>
                <ul class="list-inline text-center">
                
                
                

                

                

                
                    <li>
                        <a target="_blank"  href="https://github.com/xxxxxxbuddy">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                

                

                </ul>
                <p class="copyright text-muted">
                    Copyright &copy; Rawlence 2021
                    <br>
                    <span id="busuanzi_container_site_pv" style="font-size: 12px;">PV: <span id="busuanzi_value_site_pv"></span> Times</span>
                    <br>
                    Using theme <a target="_blank" rel="noopener" href="https://github.com/Haojen/hexo-theme-Anisina">Anisina</a>
                    <br>
                    <a target="_blank" rel="noopener" href="https://beian.miit.gov.cn/">粤ICP备19096025号-1</a>
                </p>

            </div>
        </div>
    </div>
</footer>

<!-- jQuery -->

<script src="/js/jquery.min.js"></script>


<!-- Bootstrap Core JavaScript -->

<script src="/js/bootstrap.min.js"></script>


<!-- Custom Theme JavaScript -->

<script src="/js/blog.js"></script>


<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>

<!-- jquery.tagcloud.js -->
<script>
    // only load tagcloud.js in tag.html
    if($('#tag_cloud').length !== 0){
        async("https://nowayback.cn/js/jquery.tagcloud.js",function(){
            $.fn.tagcloud.defaults = {
                //size: {start: 1, end: 1, unit: 'em'},
                color: {start: '#bbbbee', end: '#0085a1'},
            };
            $('#tag_cloud a').tagcloud();
        })
    }
</script>

<!--fastClick.js -->
<script>
    async("//cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js", function(){
        var $nav = document.querySelector("nav");
        if($nav) FastClick.attach($nav);
    })
</script>



<!-- Google Analytics -->



<!-- Baidu Tongji -->

<script>
    var _baId = 'e530fb7e94b334b3b3cb415f62302f77';
    // Originial
    var _hmt = _hmt || [];
    (function() {
        var hm = document.createElement("script");
        hm.src = "//hm.baidu.com/hm.js?" + _baId;
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(hm, s);
    })();
</script>


<!-- swiftype -->
<script type="text/javascript">
  (function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
  (w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
  e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
  })(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st');

  _st('install','','2.0.0');
</script>

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<!--wechat title img-->
<img class="wechat-title-img" src="https://s2.ax1x.com/2019/11/13/MYYvLT.jpg">
</body>

</html>
